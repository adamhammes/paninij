package org.paninij.soter2;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Set;

import com.ibm.wala.analysis.pointers.BasicHeapGraph;
import com.ibm.wala.analysis.pointers.HeapGraph;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IClassLoader;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.CallGraphBuilder;
import com.ibm.wala.ipa.callgraph.CallGraphBuilderCancelException;
import com.ibm.wala.ipa.callgraph.ClassTargetSelector;
import com.ibm.wala.ipa.callgraph.ContextSelector;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.MethodTargetSelector;
import com.ibm.wala.ipa.callgraph.propagation.HeapModel;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.summaries.BypassClassTargetSelector;
import com.ibm.wala.ipa.summaries.BypassMethodTargetSelector;
import com.ibm.wala.ipa.summaries.XMLMethodSummaryReader;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.MonitorUtil.IProgressMonitor;
import com.ibm.wala.util.WalaException;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.strings.Atom;


/**
 * Builds Zero-One CFA call graph using flow insensitive Andersen style points-to analysis with
 * entrypoints stemming from the procedures of a single template class.
 */
public class PaniniCallGraphBuilder implements CallGraphBuilder
{
    public static final String DEFAULT_EXCLUSIONS_FILENAME = "Exclusions.txt";
    
    // State generated upon instantiation and required before performing the analysis.
    protected String templateName;
    protected AnalysisScope analysisScope;
    protected IClassHierarchy classHierarchy;
    protected IClass templateClass;
    protected Set<Entrypoint> entrypoints;
    protected AnalysisOptions analysisOptions;
    protected AnalysisCache analysisCache;
    
    // Artifacts generated by performing the analysis.
    protected CallGraph callGraph;
    protected PointerAnalysis<InstanceKey> pointerAnalysis;
    protected HeapModel heapModel;
    protected HeapGraph<InstanceKey> heapGraph;


    public static PaniniCallGraphBuilder make(String templateName, String classPath)
                                                                   throws WalaException
    {
        PaniniCallGraphBuilder analysis = new PaniniCallGraphBuilder(templateName);
        analysis.init(classPath);
        analysis.perform();
        return analysis;
    }
    

    /**
     * @param templateName The name of the template to be analyzed. Should be something of the form
     *                 `-Lorg/paninij/soter/FooTemplate`.
     */
    public PaniniCallGraphBuilder(String templateName)
    {
        this.templateName = templateName;
    }
 

    public void init(String classPath) throws WalaException
    {
        initAnalysisScope(classPath, DEFAULT_EXCLUSIONS_FILENAME);
        initClassHierarchy();
        initTemplateClass();
        initEntrypoints();
        initAnalysisOptions();
        initAnalysisCache();
    }
    

    protected void initAnalysisScope(String classPath, String exclusionsFilename)
    {
        try
        {
            File exclusions = new File(exclusionsFilename);
            analysisScope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(classPath, exclusions);
        }
        catch (IOException e)
        {
            String msg = "Failed to read the exclusions file as an analysis scope: "
                       + exclusionsFilename;
            throw new IllegalArgumentException(msg);
        }
    }


    protected void initClassHierarchy() throws WalaException
    {
        this.classHierarchy = ClassHierarchy.make(analysisScope);
    }
    

    protected void initTemplateClass()
    {
        ClassLoaderReference appLoaderRef = analysisScope.getApplicationLoader();
		TypeReference typeRef = TypeReference.findOrCreate(appLoaderRef, templateName);
        this.templateClass = classHierarchy.lookupClass(typeRef);
        if (this.templateClass == null)
        {
            String msg = "Initialization of a template's `IClass` failed: " + templateName;
            throw new IllegalArgumentException(msg);
        }
    }
    

    protected void initEntrypoints()
    {
        entrypoints = CapsuleTemplateEntrypoint.makeAll(templateClass);
    }
    
    
    protected void initAnalysisOptions()
    {
        analysisOptions = new AnalysisOptions(analysisScope, entrypoints);
        ClassLoader classLoader = Util.class.getClassLoader();
        InputStream nativesSpecInput = classLoader.getResourceAsStream("natives.xml");
        XMLMethodSummaryReader nativeSpecSummary = new XMLMethodSummaryReader(nativesSpecInput,
                                                                              analysisScope);

        // Add default selectors then custom ones. The defaults will serve as the parents of the
        // custom children. The children delegate to their parents when they do not definitively
        // target a class/method.
        Util.addDefaultSelectors(analysisOptions, classHierarchy);
        setToSynthesizeNativeMethods(nativeSpecSummary);
        setToSynthesizeNativeClasses(nativeSpecSummary);
    }


    protected void initAnalysisCache()
    {
        analysisCache = new AnalysisCache();
    }


    /**
     * This performs a zero-one CFA algorithm which simultaneously builds the call graph and
     * performs the pointer analysis. It initializes all of the following fields:
     * 
     *  - callGraph
     *  - pointerAnalysis
     *  - heapModel
     *  - heapGraph
     */
    @SuppressWarnings("unchecked")
    protected void perform()
    {
        ContextSelector contextSelector = new ReceiverInstanceContextSelector();
        PropagationCallGraphBuilder builder = Util.makeZeroOneCFABuilder(analysisOptions,
                                                                         analysisCache,
                                                                         classHierarchy,
                                                                         analysisScope,
                                                                         contextSelector,
                                                                         null);
        try
        {
            callGraph = builder.makeCallGraph(analysisOptions, null);
            pointerAnalysis = builder.getPointerAnalysis();
            heapModel = pointerAnalysis.getHeapModel();
            heapGraph = new BasicHeapGraph(pointerAnalysis, callGraph);
        }
        catch (CallGraphBuilderCancelException ex)
        {
            String msg = "Call graph construction was unexpectedly cancelled: " + templateName;
            throw new IllegalArgumentException(msg);
        }
    }

    
    /**
     * TODO: Is this method name an accurate description of what this bypass logic is doing?
     */
    private void setToSynthesizeNativeMethods(XMLMethodSummaryReader natives)
    {
        MethodTargetSelector parent = analysisOptions.getMethodTargetSelector();
        MethodTargetSelector child = new BypassMethodTargetSelector(parent,
                                                                    natives.getSummaries(),
                                                                    natives.getIgnoredPackages(),
                                                                    classHierarchy);
        analysisOptions.setSelector(child);
    }


    /**
     * TODO: Is this method name an accurate description of what this bypass logic is doing?
     */
    private void setToSynthesizeNativeClasses(XMLMethodSummaryReader natives)
    {
        Atom synthetic = Atom.findOrCreateUnicodeAtom("Synthetic");
        IClassLoader syntheticLoader = classHierarchy.getLoader(analysisScope.getLoader(synthetic));

        ClassTargetSelector parent = analysisOptions.getClassTargetSelector();
        ClassTargetSelector child = new BypassClassTargetSelector(parent,
                                                                  natives.getAllocatableClasses(),
                                                                  classHierarchy,
                                                                  syntheticLoader);
        analysisOptions.setSelector(child);
    }



    public CallGraph makeCallGraph() throws IllegalArgumentException, CallGraphBuilderCancelException
    {
        return makeCallGraph(null, null);
    }
    
    
    /**
     * Arguments are expected to be null. It is recommended to use `makeCallGraph()` instead.
     */
    @Override
    public CallGraph makeCallGraph(AnalysisOptions options, IProgressMonitor monitor)
                                throws IllegalArgumentException, CallGraphBuilderCancelException
    {
        if (monitor != null) {
            String msg = "`monitor` is not supported. Argument must be null.";
            throw new IllegalArgumentException(msg);
        }
        if (options != null) {
            String msg = "Custom `options` is not supported. Argument must be null.";
            throw new IllegalArgumentException(msg);
        }

        if (callGraph == null) {
            perform();
        }
        return callGraph;
    }


    @Override
    public PointerAnalysis<InstanceKey> getPointerAnalysis()
    {
        if (pointerAnalysis == null) {
            perform();
        }
        return pointerAnalysis;
    }
    
    
    public HeapGraph<InstanceKey> getHeapGraph()
    {
        if (heapGraph == null) {
            perform();
        }
        return heapGraph;
    }


    @Override
    public AnalysisCache getAnalysisCache()
    {
        return analysisCache;
    }
}
