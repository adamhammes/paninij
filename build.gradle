description = '''
  @PaniniJ is an annotation-based realization of capsule-oriented programming
  in Java. Capsule-oriented programming is an implicitly concurrent programming
  model.
'''

allprojects  {
  group = 'org.paninij'
  version = '0.2.1-SNAPSHOT'
}

subprojects {
  // Add standard configuration to all subprojects using the 'java' plugin.
  plugins.withType(JavaPlugin).whenPluginAdded {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    jar {
      // Include sources along-side classes in compiled jars.
      from sourceSets.main.allSource
    }
    repositories {
      mavenLocal()
      mavenCentral()
    }
  }
}

// This custom `checkExamples` task wouldn't be necessary if `examples` was a
// sub-project. However, by making `examples` be its own independent Gradle
// project, it serves as a complete example of how to set up a Gradle-based
// @PaniniJ project.
task checkExamples(type: Exec) {
  // Note that `install` is used so that when examples is checked, it is
  // loading the most recent versions of `proc` and `lang` via the local Maven
  // repository.
  dependsOn tasks.getByPath(':core:proc:install')
  dependsOn tasks.getByPath(':core:lang:install')
  workingDir 'examples'
  commandLine './gradlew', 'clean', 'check'

  // Store output in a byte array. The method `checkExamples.output()` can be
  // called to obtain the output as a string.
  standardOutput = new ByteArrayOutputStream()
  ext.output = {
    return standardOutput.toString()
  }
}

task check {
  dependsOn checkExamples
  // Nothing else to do here at the moment.
}
