package org.paninij.soter;

import static org.paninij.soter.util.SoterUtil.makePointsToClosure;
import static java.text.MessageFormat.format;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.paninij.runtime.util.IdentitySet;
import org.paninij.runtime.util.IntMap;
import org.paninij.soter.cga.CallGraphAnalysis;
import org.paninij.soter.live.CallGraphLiveAnalysis;
import org.paninij.soter.live.TransferLiveAnalysis;
import org.paninij.soter.model.CapsuleTemplate;
import org.paninij.soter.transfer.TransferAnalysis;
import org.paninij.soter.transfer.TransferSite;
import org.paninij.soter.transfer.TransferSiteFactory;
import org.paninij.soter.util.Analysis;

import com.ibm.wala.analysis.pointers.HeapGraph;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.NewSiteReference;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.propagation.ArrayContentsKey;
import com.ibm.wala.ipa.callgraph.propagation.HeapModel;
import com.ibm.wala.ipa.callgraph.propagation.InstanceFieldKey;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.LocalPointerKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerKey;
import com.ibm.wala.ipa.callgraph.propagation.StaticFieldKey;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAReturnInstruction;
import com.ibm.wala.util.collections.Pair;
import com.ibm.wala.util.intset.IntIterator;
import com.ibm.wala.util.intset.IntSet;
import com.ibm.wala.util.intset.MutableIntSet;
import com.ibm.wala.util.intset.MutableSparseIntSetFactory;

public class SoterAnalysis extends Analysis
{
    // The analysis's dependencies:
    protected final CapsuleTemplate template;
    protected final CallGraphAnalysis cga;
    protected final TransferAnalysis ta;
    protected final TransferLiveAnalysis tla;
    protected final CallGraphLiveAnalysis cgla;
    protected final IClassHierarchy cha;
    
    protected final MutableSparseIntSetFactory intSetFactory;
    
    /**
     * This analysis adds its results to this map as they are generated. The keys are the
     * transferring `TransferSite` objects generated by the `TransferAnalysis` and values are
     * generated `TransferSiteResults` object.
     */
    protected final Map<TransferSite, TransferSiteResults> transferSiteResultsMap;
    
    protected final Map<IMethod, IdentitySet<TransferSite>> unsafeTransferSitesMap;
    

    public SoterAnalysis(CapsuleTemplate template, CallGraphAnalysis cga, TransferAnalysis ta,
                         TransferLiveAnalysis tla, CallGraphLiveAnalysis cgla, IClassHierarchy cha)
    {
        this.template = template;
        this.cga = cga;
        this.ta = ta;
        this.tla = tla;
        this.cgla = cgla;
        this.cha = cha;
        
        intSetFactory = new MutableSparseIntSetFactory();
        
        transferSiteResultsMap = new HashMap<TransferSite, TransferSiteResults>();
        unsafeTransferSitesMap = new HashMap<IMethod, IdentitySet<TransferSite>>();
    }

    @Override
    protected void performSubAnalyses()
    {
        cga.perform();
        ta.perform();
        tla.perform();
        cgla.perform();
    }


    @Override
    protected void performAnalysis()
    {
        buildTransferSiteResultsMap();
        buildUnsafeTransfersMap();
    }
    

    protected void buildTransferSiteResultsMap()
    {
        for (CGNode transferringNode : ta.getTransferringNodes())
        {
            for (TransferSite transferSite : ta.getTransferringSites(transferringNode))
            {
                TransferSiteResults results = new TransferSiteResults();
                
                // Find all of the live variables for this transfer site.
                results.liveVariables = new HashSet<PointerKey>();
                results.liveVariables.addAll(tla.getPointerKeysAfter(transferSite));
                results.liveVariables.addAll(cgla.getPointerKeysAfter(transferringNode));
                
                // Find all of the (transitively) live objects.
                results.liveObjects = new IdentitySet<InstanceKey>();
                for (PointerKey pointerKey : results.liveVariables) {
                    results.liveObjects.addAll(makePointsToClosure(pointerKey, cga.getHeapGraph()));
                }
                
                // For each of the transfer site's transfers, find all of the (transitively)
                // escaped objects.
                HeapModel heapModel = cga.getHeapModel();
                HeapGraph<InstanceKey> heapGraph = cga.getHeapGraph();
                IntIterator paramIter = transferSite.getTransfers().intIterator();
                while (paramIter.hasNext())
                {
                    int paramID = paramIter.next();

                    PointerKey ptr = heapModel.getPointerKeyForLocal(transferringNode, paramID);
                    IdentitySet<InstanceKey> escaped = makePointsToClosure(ptr, heapGraph);
                    results.setEscapedObjects(paramID, escaped);

                    boolean isSafeTransfer = results.liveObjects.isDisjointFrom(escaped);
                    results.setTransferSafety(paramID, isSafeTransfer);
                }
                
                transferSiteResultsMap.put(transferSite, results);
            }
        }    
    }
    

    protected void buildUnsafeTransfersMap()
    {
        for (Entry<TransferSite, TransferSiteResults> entry : transferSiteResultsMap.entrySet())
        {
            TransferSite transferSite = entry.getKey();
            TransferSiteResults results = entry.getValue();

            if (results.hasUnsafeTransfers())
            {
                IMethod method = transferSite.getNode().getMethod();
                IdentitySet<TransferSite> unsafeTransferSites = getOrMakeUnsafeTransferSites(method);
                TransferSite unsafeTransferSite = TransferSiteFactory.copyWith(transferSite, results.getUnsafeTransfers());
                unsafeTransferSites.add(unsafeTransferSite);
            }
        }
    }
    
    
    /**
     * Gets and returns the set of unsafe transfer sites associated with the given method. If there
     * isn't yet such a set in the map, then an empty set is created, added to the map, and
     * returned.
     */
    private IdentitySet<TransferSite> getOrMakeUnsafeTransferSites(IMethod method)
    {
        IdentitySet<TransferSite> unsafeTransferSites = unsafeTransferSitesMap.get(method);
        if (unsafeTransferSites == null)
        {
            unsafeTransferSites = new IdentitySet<TransferSite>();
            unsafeTransferSitesMap.put(method, unsafeTransferSites);
        }
        return unsafeTransferSites;
    }
    
    
    public String makeReport()
    {
        StringBuilder report = new StringBuilder();
        Reporter reporter = new Reporter(report);
        reporter.makeReport();
        return report.toString();
    }


    public CallGraph getCallGraph()
    {
        return cga.getCallGraph();
    }

    public HeapGraph<InstanceKey> getHeapGraph()
    {
        return cga.getHeapGraph();
    } 
    
    public CapsuleTemplate getCapsuleTemplate()
    {
        return template;
    }
    
    /**
     * @return The map of primary results generated by this analysis. The map's keys are methods on
     *         the capsule template which have been found to have unsafe transfer sites. The value
     *         associated with a method is the set of transfer sites within this method which have
     *         been found by the analysis to have unsafe transfers. The `transfers` on these
     *         `TransferSite` instances are the set of transfers which were found to be *unsafe*
     *         (rather than all of the transfers at that transfer site).
     */
    public Map<IMethod, IdentitySet<TransferSite>> getUnsafeTransferSitesMap()
    {
        return unsafeTransferSitesMap;
    }
    

    /**
     * A simple container class to hold all of the results which the analysis generates for a single
     * transfer site.
     */
    private final class TransferSiteResults
    {
        Set<PointerKey> liveVariables;
        IdentitySet<InstanceKey> liveObjects;
        MutableIntSet unsafeTransfers;
        MutableIntSet safeTransfers;
        IntMap<IdentitySet<InstanceKey>> escapedObjectsMap;
        
        public TransferSiteResults()
        {
            unsafeTransfers = intSetFactory.make();
            safeTransfers = intSetFactory.make();
            escapedObjectsMap = new IntMap<IdentitySet<InstanceKey>>();
        }
        
        public void setEscapedObjects(int transferID, IdentitySet<InstanceKey> escapedObjects)
        {
            escapedObjectsMap.put(transferID, escapedObjects);
        }
        
        public IdentitySet<InstanceKey> getEscapedObjects(int transferID)
        {
            return escapedObjectsMap.get(transferID);
        }
     
        public void setTransferSafety(int transferID, boolean isSafeTransfer)
        {
            if (isSafeTransfer) {
                safeTransfers.add(transferID);
                unsafeTransfers.remove(transferID);
            } else {
                safeTransfers.remove(transferID);
                unsafeTransfers.add(transferID);
            }
        }
        
        public boolean isSafeTransfer(int transferID)
        {
            return safeTransfers.contains(transferID);
        }
        
        public boolean isUnsafeTransfer(int transferID)
        {
            return unsafeTransfers.contains(transferID);
        }
        
        public IntSet getUnsafeTransfers()
        {
            return unsafeTransfers;
        }
        
        public IntSet getSafeTransfers()
        {
            return safeTransfers;
        }
        
        public boolean hasUnsafeTransfers()
        {
            return !unsafeTransfers.isEmpty();
        }
    }



    /**
     * Visits the contents of a (performed) `SoterAnalysis` and appends an easy to read report of
     * the analysis's results to a `StringBuilder`.
     */
    private class Reporter
    {
        private StringBuilder report;
        
        public Reporter(StringBuilder report)
        {
            assert report != null;
            this.report = report;
        }

        private void makeReport()
        {
            report.append("\n");
            report.append("=== [SOTER ANALYSIS REPORT] ===================================================\n");
            report.append("\n");
            report.append("[Capsule Template] " + template.getQualifiedName() + "\n");
            report.append("\n");
            report.append("~~~ [SUMMARY RESULTS OF UNSAFE TRANSFER SITES BY METHOD] ~~~~~~~~~~~~~~~~~~~~~~\n");
            report.append("\n");
            for (Entry<IMethod, IdentitySet<TransferSite>> entry : unsafeTransferSitesMap.entrySet())
            {
                IMethod method = entry.getKey();
                IdentitySet<TransferSite> unsafeTransferSites = entry.getValue();

                report.append("    [Method] " + method + "\n");
                for (TransferSite unsafeTransferSite : unsafeTransferSites)
                {
                    report.append("    " + unsafeTransferSite.infoString() + "\n");
                }
            }
            
            report.append("\n");
            report.append("\n");
            report.append("~~~ [FULL RESULTS BY TRANSFER SITE] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
            report.append("\n");

            for (TransferSite transferSite : transferSiteResultsMap.keySet())
            {
                TransferSiteResults results = transferSiteResultsMap.get(transferSite);

                report.append("--- [TRANSFER SITE RESULTS] ----------------------------------------------------\n");
                report.append("\n");
                report.append("    [Transfer Site Info]  " + transferSite.infoString() + "\n");
                report.append("\n");
                report.append("    [Transfer Site Debug] " + debug(transferSite) + "\n");
                report.append("\n");
                report.append("    [Live Pointer Keys]   " + debug(results.liveVariables) + "\n");
                report.append("\n");
                report.append("    [Live Instance Keys]  " + debug(results.liveObjects) + "\n");
                report.append("\n");

                IntIterator transfersIter = transferSite.getTransfers().intIterator();
                while (transfersIter.hasNext())
                {
                    int transfer = transfersIter.next();
                    report.append("    [TransferID]               " + transfer + "\n");
                    report.append("    [Escaped Instance Keys]    " + debug(results.getEscapedObjects(transfer)) + "\n");
                    report.append("    [Is Safe Transfer?]        " + results.isSafeTransfer(transfer) + "\n");
                    report.append("\n");
                }
                report.append("\n");
            }
            report.append("================================================================================\n");
        }

        private String debug(TransferSite ts)
        {
            return format("TransferSite(node = {0}, instruction = {1}, transfers = {2})",
                          debug(ts.getNode()), debug(ts.getInstruction()), ts.getTransfers());
        }
        
        private String debug(CGNode node)
        {
            return format("CGNode(method = {0}, context = {1})",
                          node.getMethod(), node.getContext());
        }
        
        private String debug(SSAInstruction instr)
        {
            if (instr instanceof SSAAbstractInvokeInstruction)
            {
                SSAAbstractInvokeInstruction invoke = (SSAAbstractInvokeInstruction) instr;
                return format("SSAAbstractInvokeInstruction(declaredTarget = {0}, programCounter = {1})",
                              invoke.getDeclaredTarget(), invoke.getCallSite().getProgramCounter());
            }
            else if (instr instanceof SSAReturnInstruction)
            {
                SSAReturnInstruction ret = (SSAReturnInstruction) instr;
                return format("SSAReturnInstruction(result = {0})", ret.getResult());
            }
            else
            {
                String msg = "Attempted to stringify unexpected `SSAInstruction` type.";
                throw new RuntimeException(msg);
            }
        }

        private String debug(Set<PointerKey> set)
        {
            List<String> strings = new ArrayList<String>();
            for (PointerKey ptr : set) {
                strings.add(debug(ptr));
            }
            return "{" + String.join(", ", strings) + "}";
        }
        
        private String debug(PointerKey ptr)
        {
            if (ptr instanceof InstanceFieldKey) return debug((InstanceFieldKey) ptr);
            else if (ptr instanceof LocalPointerKey) return debug((LocalPointerKey) ptr);
            else if (ptr instanceof StaticFieldKey) return debug((StaticFieldKey) ptr);
            else if (ptr instanceof ArrayContentsKey) return debug((ArrayContentsKey) ptr);
            else throw new RuntimeException("Found `PointerKey` which can't be handled: " + ptr);
        }
        
        private String debug(InstanceFieldKey ptr)
        {
            return format("InstanceFieldKey(field = {0})", ptr.getField());
        }

        private String debug(LocalPointerKey ptr)
        {
            return format("LocalPointerKey(method = {0}, valueNumber = {1})",
                          ptr.getNode().getMethod(), ptr.getValueNumber());
        }

        private String debug(StaticFieldKey ptr)
        {
            return format("StaticFieldKey(field = {0})", ptr.getField());
        }
        
        private String debug(ArrayContentsKey ptr)
        {
            return format("ArrayContentsKey()");
        }

        private String debug(IdentitySet<InstanceKey> set)
        {
            List<String> strings = new ArrayList<String>();
            for (InstanceKey inst : set) {
                strings.add(debug(inst));
            }
            return "{" + String.join(", ", strings) + "}";
        }

        private String debug(InstanceKey inst)
        {
            Iterator<Pair<CGNode, NewSiteReference>> iter = inst.getCreationSites(cga.getCallGraph());

            // Assume that the returned iterator has exactly one `next()`.
            assert iter.hasNext() == true;
            Pair<CGNode, NewSiteReference> creationSite = iter.next();
            assert iter.hasNext() == false;

            return format("InstanceKey(method = {0}, programCounter = {1}, context = {2})",
                          creationSite.fst.getMethod(),
                          creationSite.snd.getProgramCounter(),
                          creationSite.fst.getContext());
        }
    }
}
