package org.paninij.soter.cga;

import org.paninij.soter.model.CapsuleTemplate;
import org.paninij.soter.util.Analysis;

import com.ibm.wala.analysis.pointers.BasicHeapGraph;
import com.ibm.wala.analysis.pointers.HeapGraph;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.CallGraphBuilderCancelException;
import com.ibm.wala.ipa.callgraph.ContextSelector;
import com.ibm.wala.ipa.callgraph.propagation.HeapModel;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.cha.IClassHierarchy;


/**
 * Builds Zero-One CFA call graph using flow insensitive Andersen style points-to analysis with
 * entrypoints stemming from the procedures of a single template class.
 */
public class CallGraphAnalysis implements Analysis
{
    // Analysis dependencies:
    protected final CapsuleTemplate template;
    protected final IClassHierarchy cha;
    protected final AnalysisOptions options;
    protected final AnalysisCache cache;
    
    // Artifacts generated by performing the analysis:
    protected CallGraph callGraph;
    protected PointerAnalysis<InstanceKey> pointerAnalysis;
    protected HeapModel heapModel;
    protected HeapGraph<InstanceKey> heapGraph;
    
    protected boolean hasBeenPerformed;

    public CallGraphAnalysis(CapsuleTemplate template, IClassHierarchy cha, AnalysisOptions options)
    {
        this(template, cha, options, new AnalysisCache());
    }
    
    public CallGraphAnalysis(CapsuleTemplate template, IClassHierarchy cha, AnalysisOptions options,
                             AnalysisCache cache)
    {
        this.template = template;
        this.cha = cha;
        this.options = options;
        this.cache = cache;
        
        hasBeenPerformed = false;
    }

    /**
     * This performs a zero-one CFA algorithm which simultaneously builds the call graph and
     * performs the pointer analysis. Note that by calling this function, any entrypoints stored in
     * `options` will be overridden with new entrypoints.
     * 
     * @see org.paninij.soter.util.Analysis#perform()
     */
    @Override
    @SuppressWarnings("unchecked")
    public void perform()
    {
        if (hasBeenPerformed) {
            return;
        }

        options.setEntrypoints(CapsuleTemplateEntrypoint.makeAll(template.getTemplateClass()));

        ContextSelector contextSelector = new ReceiverInstanceContextSelector();
        PropagationCallGraphBuilder builder = Util.makeZeroOneCFABuilder(options, cache, cha,
                                                                         cha.getScope(),
                                                                         contextSelector, null);
        try
        {
            callGraph = builder.makeCallGraph(options, null);
            pointerAnalysis = builder.getPointerAnalysis();
            heapModel = pointerAnalysis.getHeapModel();
            heapGraph = new BasicHeapGraph(pointerAnalysis, callGraph);
        }
        catch (CallGraphBuilderCancelException ex)
        {
            String msg = "Call graph construction was unexpectedly cancelled: ";
            throw new IllegalArgumentException(msg + template.toString());
        }
        
        hasBeenPerformed = true;
    }
    
    public CallGraph getCallGraph()
    {
        if (callGraph == null)
        {
            String msg = "Must call `perform()` before `getCallGraph()`.";
            throw new IllegalStateException(msg);
        }

        return callGraph;
    }

    public HeapModel getHeapModel()
    {
        return heapModel;
    }

    public PointerAnalysis<InstanceKey> getPointerAnalysis()
    {
        if (pointerAnalysis == null)
        {
            String msg = "Must call `perform()` before `getCallGraph()`.";
            throw new IllegalStateException(msg);
        }
        return pointerAnalysis;
    }
    
    public HeapGraph<InstanceKey> getHeapGraph()
    {
        if (heapGraph == null)
        {
            String msg = "Must call `perform()` before `getHeapGraph()`.";
            throw new IllegalStateException(msg);
        }
        return heapGraph;
    }
}
